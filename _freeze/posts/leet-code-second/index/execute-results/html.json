{
  "hash": "1d1669d7ea18803abbe6fae3dffe1b78",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"leet code 1\"\ndescription: \"Digging into the leet code probelem 2\"\ndate: \"2025-06-30\"\ncategories:\n  - python\n  - programming\n---\n\nLink: https://leetcode.com/problems/add-two-numbers/description/\n\nWith the arrival of LLM such as ChatGPT that are capable of answering simple-to-medium questions, getting the code that works for us may not be that hard. However, I still think it is important to understand the problem and the solution. We would like to think about \"why\". We let LLM handle the \"how\" part. In this post, we will try to understand the problem and the solution for the first leet code problem: Two Sum.\n\n\n## Problem Statement\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n```\nExample: \n342: 2 -> 4 -> 3\n465: 5 -> 6 -> 4\nResult: 807: 7 -> 0 -> 8\n```\n\n\n## Solution\nFirst, note that the problem says 'two non-empty linked lists'. This means that the objects that are provided as input are of type `linked list`. It is important to understand the properties of this object. \n\n\n**Note:** <br>\nThe `linked list` is a data structure that consists of nodes, where each node contains a value and a reference to the next node in the list. The `ListNode` class defines the structure of each node in the linked list. If we look at the `code` window, we can see that the definition of class `ListNode` is provided. \n\n::: {#e915dda9 .cell execution_count=1}\n``` {.python .cell-code}\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n```\n:::\n\n\nSo, if I assume there exists a linked list like: `A-->B-->C`, then it means `A` points to `B`, and `B` points to `C`. The last node, `C`, points to `None`, indicating the end of the list. In the linked list, the root is provided. So, if we start from `A`, we can access `B` by `A.next`, and we can access `C` by `B.next`, and so on. So, when we are asked to return the result\nas a linked list, we need to provide the root of that linked list.\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef sum_linked_lists(L1, L2):\n    carry = 0\n    dummy_head = ListNode(0)\n    current = dummy_head\n\n    while L1 or L2 or carry:\n        val1 = L1.val if L1 else 0\n        val2 = L2.val if L2 else 0\n        total = val1 + val2 + carry\n        carry = total // 10\n        current.next = ListNode(total % 10)\n        current = current.next\n        if L1:\n            L1 = L1.next\n        if L2:\n            L2 = L2.next\n\n    return dummy_head.next\n```\n\n\nThe function above was provided by co-pilot. \n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}